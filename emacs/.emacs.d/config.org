#+STARTUP: overview
* package management
** set up melpa
#+BEGIN_SRC emacs-lisp
  (setq package-enable-at-startup nil)
  (require 'package)
  (add-to-list 'package-archives
               '("melpa-stable" . "https://stable.melpa.org/packages/") t)
  (add-to-list 'package-archives
               '("melpa" . "https://melpa.org/packages/") t)
  (package-initialize)
#+END_SRC
** use-package
#+BEGIN_SRC emacs-lisp
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))
  (require 'use-package)
  (setq use-package-always-ensure t)
  (setq use-package-always-defer t)
  (setq use-package-verbose t)
#+END_SRC
** trying out packages
#+BEGIN_SRC emacs-lisp
  (use-package try
    :commands try)
#+END_SRC
* diminish
hide certain minor modes from the mode line
#+BEGIN_SRC emacs-lisp
  (use-package diminish)
#+END_SRC
some built-in modes to diminish
#+BEGIN_SRC emacs-lisp
  (diminish 'global-auto-revert-mode)
  (diminish 'auto-revert-mode)
  (diminish 'whitespace-mode)
  (diminish 'abbrev-mode)
  (diminish 'eldoc-mode)
#+END_SRC
* change defaults / enable built-in features
** custom
change where customize stores its values
#+BEGIN_SRC emacs-lisp
  (setq custom-file "~/.emacs.d/customize.el")
  (load custom-file 'noerror)
#+END_SRC
** backups
#+BEGIN_SRC emacs-lisp
  (setq make-backup-files t
        vc-make-backup-files t  ; make backups of version-controlled files
        backup-directory-alist '(("." . "~/.emacs.d/backup"))
        version-control t       ; use version numbers on backups
        delete-old-versions t   ; delete excess backup files silently
        kept-new-versions 20
        kept-old-versions 5)
#+END_SRC
** auto-saves
#+BEGIN_SRC emacs-lisp
  (setq auto-save-file-name-transforms '((".*" "~/.emacs.d/auto-save-list/" t))
        auto-save-interval 200)
#+END_SRC
** automatically refresh buffers
#+BEGIN_SRC emacs-lisp
  (global-auto-revert-mode 1)
#+END_SRC
** saving history
from [[http://pages.sachachua.com/.emacs.d/Sacha.html][Sacha Chua's Emacs Configuration]]
#+BEGIN_SRC emacs-lisp
  (eval-when-compile
    (require 'savehist))

  (setq savehist-file "~/.emacs.d/savehist")
  (savehist-mode 1)
  (setq history-length t
        history-delete-duplicates t
        savehist-save-minibuffer-history t
        savehist-additional-variables
            '(kill-ring search-ring regexp-search-ring register-alist))
#+END_SRC
** recentf
#+BEGIN_SRC emacs-lisp
  (eval-when-compile
    (require 'recentf))

  (setq recentf-max-menu-items 100
        recentf-max-saved-items 100)
#+END_SRC
** increase some values
#+BEGIN_SRC emacs-lisp
  (setq kill-ring-max 1000
        max-specpdl-size 10000
        max-lisp-eval-depth 10000)
#+END_SRC
** navigation
*** scrolling behavior
don't recenter point while scrolling
#+BEGIN_SRC emacs-lisp
  (setq scroll-conservatively 100)
#+END_SRC
increase scroll context
#+BEGIN_SRC emacs-lisp
  (setq next-screen-context-lines 5)
#+END_SRC
*** sentence-based navigation
#+BEGIN_SRC emacs-lisp
  (setq sentence-end-double-space nil)
#+END_SRC
*** buffer listing
use ibuffer instead of list-buffers
#+BEGIN_SRC emacs-lisp
  (defalias #'list-buffers #'ibuffer)
#+END_SRC
*** back to indentation
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "M-i") #'back-to-indentation)
#+END_SRC
*** toggle between the last two buffers
#+BEGIN_SRC emacs-lisp
  (defun my/toggle-previous-buffer ()
      "Toggles to the previously active buffer."
    (interactive)
    (switch-to-buffer nil))

  (global-set-key (kbd "M-W") #'my/toggle-previous-buffer)
#+END_SRC
** registers
#+BEGIN_SRC emacs-lisp
  (setq register-preview-delay 0.4)
#+END_SRC
** indentation
use spaces instead of tabs for indentation
#+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode nil)
#+END_SRC
avoid arrow keys in indent-rigidly
#+BEGIN_SRC emacs-lisp
  (define-key indent-rigidly-map (kbd "H") #'indent-rigidly-left)
  (define-key indent-rigidly-map (kbd "L") #'indent-rigidly-right)
  (define-key indent-rigidly-map (kbd "h") #'indent-rigidly-left-to-tab-stop)
  (define-key indent-rigidly-map (kbd "S-TAB") #'indent-rigidly-left-to-tab-stop)
  (define-key indent-rigidly-map (kbd "<backtab>") #'indent-rigidly-left-to-tab-stop)
  (define-key indent-rigidly-map (kbd "l") #'indent-rigidly-right-to-tab-stop)
  (define-key indent-rigidly-map (kbd "TAB") #'indent-rigidly-right-to-tab-stop)
  (define-key indent-rigidly-map (kbd "<tab>") #'indent-rigidly-right-to-tab-stop)
#+END_SRC
dwim wrapper around `indent-rigidly`
#+BEGIN_SRC emacs-lisp
  (defun my/indent-rigidly-dwim (arg)
    "Call `indent-rigidly' on the current region if active,
  else call it on the current line."
    (interactive "P")
    ;; `indent-rigidly' seems not to work when the cursor is at the
    ;; beginning of the line
    (if (bolp)
        (forward-char 1))
    (if (null arg)
        (if (region-active-p)
            (call-interactively #'indent-rigidly)
          (save-excursion
            (set-mark (point-at-bol))
            (goto-char (point-at-eol))
            ;; (activate-mark)
            (call-interactively #'indent-rigidly)))
      (if (region-active-p)
          (indent-rigidly (region-beginning) (region-end) arg)
        (indent-rigidly (point-at-bol) (point-at-eol) arg))))

  (global-set-key (kbd"C-x TAB") #'my/indent-rigidly-dwim)
#+END_SRC
** selection / mark
*** selecting rectangles
map M-RET to start a rectangle selection with cua mode
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "M-<return>") #'cua-rectangle-mark-mode)
#+END_SRC
*** delete selection
delete the active region's contents when something is typed
#+BEGIN_SRC emacs-lisp
  (delete-selection-mode 1)
#+END_SRC
*** disable mark commands when the region is inactive
#+BEGIN_SRC emacs-lisp
  (setq mark-even-if-inactive nil)
#+END_SRC
** configure line wrapping / truncating
#+BEGIN_SRC emacs-lisp
  ; (global-visual-line-mode 1)
  (setq-default truncate-lines :t)        ; truncate lines by default

  (add-hook 'help-mode-hook #'turn-on-visual-line-mode)
  (add-hook 'Info-mode-hook #'turn-on-visual-line-mode)
#+END_SRC
** show matching parentheses
#+BEGIN_SRC emacs-lisp
  (show-paren-mode 1)
#+END_SRC
** automatically close parentheses etc.
#+BEGIN_SRC emacs-lisp
;(electric-pair-mode 1)
#+END_SRC
** window management
*** winner-mode
enable winner-mode to be able to undo/redo window commands
#+BEGIN_SRC emacs-lisp
  (winner-mode 1)
#+END_SRC
*** show cursor in non-selected windows
#+BEGIN_SRC emacs-lisp
  (setq-default cursor-in-non-selected-windows t)
#+END_SRC
** scratch buffer
remove the initial message shown in the scratch buffer
#+BEGIN_SRC emacs-lisp
  (setq initial-scratch-message "")
#+END_SRC
** show whitespace in programming modes
#+BEGIN_SRC emacs-lisp
  (eval-when-compile
    (require 'whitespace))

  (setq whitespace-style
        '(face trailing tabs lines-tail space-after-tab space-before-tab tab-mark newline newline-mark empty)
        whitespace-line-column 80
        whitespace-display-mappings '((space-mark 32 [183] [46])  ; "·", "."
                                      (space-mark 160 [164] [95]) ; "¤", "_"
                                      (newline-mark 10 [172 10] [36 10]) ; "¬", "$"
                                      (tab-mark 9 [187 9] [92 9]))) ; "»", "\"

  (custom-set-faces '(whitespace-trailing ((t (:background "orange red" :foreground "gold"))))
                    '(whitespace-line ((t (:underline t :foreground nil :background nil))))
                    '(whitespace-newline ((t (:foreground "dim gray" :background nil))))
                    '(whitespace-empty ((t (:background "black")))))

  (add-hook 'prog-mode-hook (lambda () (whitespace-mode 1)))
  (add-hook 'conf-mode-hook (lambda () (whitespace-mode 1)))
#+END_SRC
** bind useful but unbound commands
*** revert-buffer
#+BEGIN_SRC emacs-lisp
  (defun my/revert-buffer-only-prompt-if-modified ()
    "Acts like `revert-buffer' but only prompts if the buffer has been modified"
    (interactive)
    (if (buffer-modified-p)
        (revert-buffer)
      (revert-buffer nil t)
      (message (concat "Reverted buffer " (buffer-name (current-buffer))))))
  (global-set-key (kbd "<f5>") #'my/revert-buffer-only-prompt-if-modified)
#+END_SRC
*** font-lock-fontify-buffer (refresh syntax highlighting)
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-<f5>") #'font-lock-fontify-buffer)
#+END_SRC
*** find-file-at-point
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "M-g f") #'find-file-at-point)
#+END_SRC
*** toggle truncate lines
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c t t") #'toggle-truncate-lines)
#+END_SRC
*** delete trailing whitespace
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c t d") #'delete-trailing-whitespace)
#+END_SRC
** use hippie-expand
#+BEGIN_SRC emacs-lisp
  ;; get rid of compiler warnings
  (eval-when-compile
    (declare-function try-expand-line "hippie-exp" (old)))

  ;; move the line expansion to the very end of the list
  (delq #'try-expand-line hippie-expand-try-functions-list)
  (add-to-list 'hippie-expand-try-functions-list #'try-expand-line 'append)

  ;; M-/ normally runs dabbrev-expand
  (global-set-key (kbd "M-/") #'hippie-expand)
#+END_SRC
** use abbrev
#+BEGIN_SRC emacs-lisp
  (setq abbrev-file-name
        "~/.emacs.d/abbrev_definitions"
        save-abbrevs t)                   ; save abbrevs when files are saved
  (setq-default abbrev-mode t)
#+END_SRC
** backward-kill-sexp
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-M-<backspace>") #'backward-kill-sexp)
#+END_SRC
** final newlines
#+BEGIN_SRC emacs-lisp
  (setq require-final-newline t
        mode-require-final-newline t)
#+END_SRC
** remap toggle input method
I use C-\ for company
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "<F9>") #'toggle-input-method) ; in case I ever need this...
#+END_SRC
** use visually relative line numbers in display-line-numbers-mode
#+BEGIN_SRC emacs-lisp
  (eval-when-compile
    (require 'display-line-numbers))

  (setq display-line-numbers-type 'visual)
#+END_SRC
** use zsh in ansi-term
#+BEGIN_SRC emacs-lisp
  (defvar my-term-shell "/bin/zsh")
  (defadvice ansi-term (before force-zsh)
    (interactive (list my-term-shell)))
  (ad-activate 'ansi-term)
#+END_SRC
** use regex search by default
#+BEGIN_SRC emacs-lisp
  ;; (using swiper for forward search right now)
  ;; (global-set-key (kbd "C-s") #'isearch-forward-regexp)
  (global-set-key (kbd "C-r") #'isearch-backward-regexp)
#+END_SRC
* hydra
#+BEGIN_SRC emacs-lisp
  (use-package hydra
    :defer nil
    :config (require 'hydra))             ; somehow it doesn't work without this
#+END_SRC
** window management hydra
functions from hydra_examples.el
#+BEGIN_SRC emacs-lisp
  (require 'windmove)
  (require 'hydra)

  (defun hydra-move-splitter-left (arg)
    "Move window splitter left."
    (interactive "p")
    (if (let ((windmove-wrap-around))
          (windmove-find-other-window 'right))
        (shrink-window-horizontally arg)
      (enlarge-window-horizontally arg)))

  (defun hydra-move-splitter-right (arg)
    "Move window splitter right."
    (interactive "p")
    (if (let ((windmove-wrap-around))
          (windmove-find-other-window 'right))
        (enlarge-window-horizontally arg)
      (shrink-window-horizontally arg)))

  (defun hydra-move-splitter-up (arg)
    "Move window splitter up."
    (interactive "p")
    (if (let ((windmove-wrap-around))
          (windmove-find-other-window 'up))
        (enlarge-window arg)
      (shrink-window arg)))

  (defun hydra-move-splitter-down (arg)
    "Move window splitter down."
    (interactive "p")
    (if (let ((windmove-wrap-around))
          (windmove-find-other-window 'up))
        (shrink-window arg)
      (enlarge-window arg)))
#+END_SRC
hydra modified from [[https://github.com/abo-abo/hydra/wiki/Window-Management][Window Management Hydra in the Hydra Wiki]]
#+BEGIN_SRC emacs-lisp
  ;; get rid of compiler warnigns
  (eval-when-compile
    (declare-function winner-redo "winner" ())
    (declare-function winner-undo "winner" ()))

  (defhydra hydra-window (:color red
                          :hint nil
                          :idle 0.4)
    "
   Split: _M-h_/_M-j_/_M-k_/_M-l_
  Delete: _o_nly, _dw_in,  _db_buf, _x_: del current win, _i_: ace one
    Move: _s_wap
  Resize: [C-]_H_/_J_/_K_/_L_
  Frames: _f_rame new, _df_rame
    Misc: _b_uffer, book_m_ark, _u_ndo, _r_edo, _M-M_aximize, _M-m_inimize, _M-b_alance"
    ("h" windmove-left)
    ("j" windmove-down)
    ("k" windmove-up)
    ("l" windmove-right)
    ("C-h" hydra-move-splitter-left)
    ("H" (lambda () (interactive) (hydra-move-splitter-left 5)))
    ("C-j" hydra-move-splitter-down)
    ("J" (lambda () (interactive) (hydra-move-splitter-down 5)))
    ("C-k" hydra-move-splitter-up)
    ("K" (lambda () (interactive) (hydra-move-splitter-up 5)))
    ("C-l" hydra-move-splitter-right)
    ("L" (lambda () (interactive) (hydra-move-splitter-right 5)))
    ("M-h" (lambda ()
             (interactive)
             (split-window-right)
             (switch-to-buffer (other-buffer))))
    ("M-j" (lambda ()
             (interactive)
             (split-window-below)
             (windmove-down)
             (switch-to-buffer (other-buffer))))
    ("M-k" (lambda ()
             (interactive)
             (split-window-below)
             (switch-to-buffer (other-buffer))))
    ("M-l" (lambda ()
             (interactive)
             (split-window-right)
             (windmove-right)
             (switch-to-buffer (other-buffer))))
    ("x" delete-window)
    ("X" kill-buffer-and-window)
    ("u" winner-undo)
    ("r" winner-redo) ;;Fixme, not working?
    ("o" delete-other-windows :exit t)
    ("a" ace-window)
    ("M-o" ace-window :exit t)
    ("f" make-frame :exit t)
    ("s" ace-swap-window)
    ("db" kill-this-buffer)
    ("df" delete-frame :exit t)
    ("dw" ace-delete-window)
    ("q" nil)
    ("<escape>" nil)
    ("<return>" nil)
    ("i" ace-delete-other-windows :color blue)
    ("b" ido-switch-buffer)
    ("m" bookmark-jump)
    ("M-M" maximize-window)
    ("M-m" minimize-window)
    ("M-b" balance-windows))

  (global-set-key (kbd "M-o") #'hydra-window/body)
  (global-set-key (kbd "M-O") #'ace-window)
#+END_SRC
** apropos hydra
taken from hydra-examples.el
#+BEGIN_SRC emacs-lisp
  (defhydra hydra-apropos (:color blue
                           :hint nil
                           :idle 0.4)
    "
  _a_propos        _c_ommand
  _d_ocumentation  _l_ibrary
  _v_ariable       _u_ser-option
  valu_e_          _i_nfo manual"
    ("a" apropos)
    ("d" apropos-documentation)
    ("v" apropos-variable)
    ("c" apropos-command)
    ("l" apropos-library)
    ("u" apropos-user-option)
    ("e" apropos-value)
    ("i" info-apropos)
    ("q" nil)
    ("<escape>" nil)
    ("<return>" nil))

  (global-set-key (kbd "C-h C-a") #'hydra-apropos/body)
#+END_SRC
* programming mode customizations
#+BEGIN_SRC emacs-lisp
  ;; (setq linum-format "%5d ")
  (add-hook 'prog-mode-hook
            (lambda ()
              (display-line-numbers-mode 1)
              (subword-mode 1) ; allows you to jump by words in CamelCase words
              (diminish 'subword-mode) ; hide subword mode from modeline
              (flyspell-prog-mode)))   ; check spelling in comments

  ;; fix linum text-scale-adjust
  ;; (eval-after-load "linum"
  ;;   '(set-face-attribute 'linum nil :height 100))
#+END_SRC
* text mode customizations
#+BEGIN_SRC emacs-lisp
  (add-hook 'text-mode-hook
            (lambda () (flyspell-mode 1)))

#+END_SRC
** text mode company
(stolen from [[http://blog.binchen.org/posts/emacs-auto-completion-for-non-programmers.html][here]])
#+BEGIN_SRC emacs-lisp
  (with-eval-after-load 'company
    (defvar company-backends)
    (defvar my/company-ispell-backend)
    (defun my/text-mode-hook-setup ()
      ;; making `company-backends' local is critcal
      ;; or else, you will have completion in every major mode, that's very annoying!
      (make-local-variable 'company-backends)

      (setq my/company-ispell-backend 'company-ispell)

      ;; company-ispell is the plugin to complete words
      (add-to-list 'company-backends my/company-ispell-backend)

      ;; OPTIONAL, if `company-ispell-dictionary' is nil, `ispell-complete-word-dict' is used
      ;;  but I prefer hard code the dictionary path. That's more portable.
      (let ((dictionary  "/usr/share/dict/words"))
        (when (file-exists-p dictionary)
          (defvar ispell-complete-word-dict dictionary)))
      ;; (setq company-ispell-dictionary (file-truename "~/.emacs.d/misc/english-words.txt"))
      )

    ;; get rid of compiler warnings
    (eval-when-compile
      (declare-function my/text-mode-hook-setup "config" ()))

    (add-hook 'text-mode-hook #'my/text-mode-hook-setup)

    (defun my/toggle-company-ispell ()
      (interactive)
      (cond
       ((memq my/company-ispell-backend company-backends)
        (setq company-backends (delete my/company-ispell-backend company-backends))
        (message "company-ispell disabled"))
       (t
        (add-to-list 'company-backends my/company-ispell-backend)
        (message "company-ispell enabled!")))))
#+END_SRC
* dwim
** eval region or last sexp
#+BEGIN_SRC emacs-lisp
  (defun my/eval-dwim (arg)
    "Call either `eval-region' if the region is active or `eval-last-sexp' otherwise.
  ARG is passed to `eval-last-sexp' and is ignored if the region is active."
    (interactive "P")
    (if (region-active-p)
        (eval-region (region-beginning) (region-end))
      (eval-last-sexp arg)))

  (global-set-key (kbd "C-x C-e") #'my/eval-dwim)
#+END_SRC
** whole line or region mode (disabled)
#+BEGIN_SRC emacs-lisp
  ;; (use-package whole-line-or-region
  ;;   :bind (("C-w" . whole-line-or-region-kill-region)
  ;;          ("M-w" . whole-line-or-region-kill-ring-save)
  ;;          ("C-y" . whole-line-or-region-yank))
  ;;   :diminish whole-line-or-region-mode)
#+END_SRC
** change casing
#+BEGIN_SRC emacs-lisp
  (defhydra hydra-casing (:color blue
                           :hint nil
                           :idle 0.3)
    "change casing"
    ("M-u" upcase-dwim :exit t)
    ("M-l" downcase-dwim :exit t)
    ("M-d" downcase-dwim :exit t)
    ("M-c" capitalize-dwim :exit t)
    ("u" upcase-dwim "up" :exit nil)
    ("l" downcase-dwim :exit nil)
    ("d" downcase-dwim "down" :exit nil)
    ("c" capitalize-dwim "capitalize" :exit nil)
    ("q" nil)
    ("<escape>" nil)
    ("<return>" nil))

  (global-set-key (kbd "M-c") #'hydra-casing/body)
#+END_SRC
** remove whitespace
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "M-SPC") (lambda (pref) (interactive "p") (cycle-spacing pref nil 'fast)))
#+END_SRC
** TODO narrowing/widening dwim
* crux
#+BEGIN_SRC emacs-lisp
  (use-package crux
    :bind (("C-c e"         . crux-eval-and-replace)
           ("C-c O"         . crux-open-with)
           ("C-c C"         . crux-cleanup-buffer-or-region)
           ("C-x 4 t"       . crux-transpose-windows)
           ("C-c d"         . crux-duplicate-current-line-or-region)
           ("C-c i"         . crux-ispell-word-then-abbrev)
           ("C-<return>"    . crux-smart-open-line)
           ("C-o"           . crux-smart-open-line-above)))
#+END_SRC
* ace-window
#+BEGIN_SRC emacs-lisp
   (use-package ace-window
     :commands (ace-window ace-swap-window ace-delete-other-windows ace-delete-window)
     :bind (("C-x o" . ace-window))
     :init (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
     :config (progn (custom-set-faces
                     '(aw-leading-char-face
                       ((t (:foreground "deep sky blue" :height 3.0)))))))
#+END_SRC
* ivy and swiper
#+BEGIN_SRC emacs-lisp
  (use-package flx)
  (use-package counsel
    :defer nil                            ; TODO manually map all things instead of using counsel-mode / ivy-mode
    :diminish (counsel-mode ivy-mode)
    :bind (("C-s"     . swiper)
           ("C-c C-r" . ivy-resume)
           ("C-h C-l" . counsel-find-library)
           ("C-h C-i" . counsel-info-lookup-symbol)
           ("C-h C-c" . counsel-colors-web)
           ("C-h C-u" . counsel-unicode-char)
           ("M-s l"   . counsel-locate)
           ("M-s a"   . counsel-ag)
           ("M-s f"   . counsel-fzf)
           ("M-s g"   . counsel-git)
           ("M-s c"   . counsel-colors-web)
           ("M-w"     . my/switch-buffer-or-kill-ring-save))
    :init

    (defun my/switch-buffer-or-kill-ring-save ()
      "When the region is active, call `kill-ring-save', else call `ivy-switch-buffer'"
      (interactive)
      (if (region-active-p)
          (kill-ring-save :ignore :ignore :save-region-instead)
        (ivy-switch-buffer)))

    (setq ivy-use-virtual-buffers t       ; add recent files and bookmarks to buffer list
          ivy-initial-inputs-alist nil    ; don't prepend "^" by default
          ivy-count-format "%d/%d "
          ivy-wrap t                      ; wrap around after first/last match
          ivy-extra-directories nil       ; don't automatically add "." and ".." when finding a file
          ;; ignore files that start with a dot
          ;; (they can still be included in the results if the search string starts with a dot)
          counsel-find-file-ignore-regexp "\\`\\."
          counsel-find-file-at-point t    ; add file at point to file listb
          ivy-format-function 'my/ivy-format-function-arrow ; display an arrow next to current candiate
          ivy-height 12
          ivy-re-builders-alist
          '((counsel-find-file    . ivy--regex-plus)
            (swiper               . ivy--regex-plus)
            (counsel-unicode-char . ivy--regex-plus)
            (t                    . ivy--regex-fuzzy)))
    :config
    (ivy-mode 1)
    (counsel-mode 1))
#+END_SRC
** custom format function
#+BEGIN_SRC emacs-lisp
  ;; modified from ivy.el
  (require 'ivy)
  (defun my/ivy-format-function-arrow (cands)
    "Transform CANDS into a string for minibuffer."
    (ivy--format-function-generic
     (lambda (str)
       (concat "-> " (ivy--add-face str 'ivy-current-match)))
     (lambda (str)
       (concat "   " str))
     cands
     "\n"))
#+END_SRC
* move-text
#+BEGIN_SRC emacs-lisp
  (use-package move-text
    :bind (("M-p" . move-text-up)
           ("M-n" . move-text-down)))
#+END_SRC
* imenu-anywhere
#+BEGIN_SRC emacs-lisp
  (use-package imenu-anywhere
    :after ivy
    :bind (("M-I" . ivy-imenu-anywhere)))
#+END_SRC
* avy
#+BEGIN_SRC emacs-lisp
  (use-package avy
    :bind (("M-k" . avy-goto-char)
           ("M-m" . avy-goto-char-in-line)
           ("M-j" . avy-goto-word-1)
           ("M-l" . avy-goto-line)))
#+END_SRC
** avy zap
#+BEGIN_SRC emacs-lisp
  (use-package avy-zap
    :bind (("M-z" . avy-zap-to-char)
           ("C-t" . avy-zap-up-to-char)))
#+END_SRC
* which-key
#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :commands (which-key-mode which-key-show-top-level which-key-show-major-mode)
    :diminish which-key-mode
    :bind (("C-h C-t" . which-key-show-top-level)
           ("C-h C-m" . which-key-show-major-mode))
    :init
    (setq which-key-idle-delay 0.3)
    :hook (emacs-startup . which-key-mode))
#+END_SRC
* undo-tree
use undo-tree to get a navigable tree view of the buffer's history (using hjkl)
note that it can limit undos to the active region
#+BEGIN_SRC emacs-lisp
  (use-package undo-tree
    :defer nil
    :diminish undo-tree-mode
    :init (setq undo-tree-visualizer-diff t ; show diff in undo tree ("d" toggles)
                undo-tree-visualizer-timestamps t ; show timestamps ("t" toggles)
                undo-tree-auto-save-history t ; save history to a file
                undo-tree-history-directory-alist '((".*" . "~/.emacs.d/undo-tree/")))
    :config
    ;; get rid of compiler warnings...
    (require 'undo-tree)
    (eval-when-compile
      (declare-function undo-tree-visualize-switch-branch-left "undo-tree" (arg))
      (declare-function undo-tree-visualize-switch-branch-right "undo-tree" (arg))
      (declare-function undo-tree-visualize-redo "undo-tree" (&optional arg))
      (declare-function undo-tree-visualize-undo "undo-tree" (&optional arg))
      (declare-function undo-tree-visualize-redo-to-x "undo-tree" (&optional x))
      (declare-function undo-tree-visualize-undo-to-x "undo-tree" (&optional x))
      (declare-function undo-tree-visualizer-quit "undo-tree" ())
      (declare-function undo-tree-visualizer-select-left "undo-tree" (&optional arg))
      (declare-function undo-tree-visualizer-select-right "undo-tree" (&optional arg))
      (declare-function undo-tree-visualizer-select-next "undo-tree" (&optional arg))
      (declare-function undo-tree-visualizer-select-previous "undo-tree" (&optional arg))
      (declare-function undo-tree-visualizer-set "undo-tree" (&optional pos)))
    (global-undo-tree-mode 1)
    (define-key undo-tree-visualizer-mode-map (kbd "h") #'undo-tree-visualize-switch-branch-left)
    (define-key undo-tree-visualizer-mode-map (kbd "j") #'undo-tree-visualize-redo)
    (define-key undo-tree-visualizer-mode-map (kbd "k") #'undo-tree-visualize-undo)
    (define-key undo-tree-visualizer-mode-map (kbd "l") #'undo-tree-visualize-switch-branch-right)
    (define-key undo-tree-visualizer-mode-map (kbd "K") #'undo-tree-visualize-undo-to-x)
    (define-key undo-tree-visualizer-mode-map (kbd "J") #'undo-tree-visualize-redo-to-x)
    (define-key undo-tree-visualizer-mode-map (kbd "<return>") #'undo-tree-visualizer-quit)
    (define-key undo-tree-visualizer-selection-mode-map (kbd "h") #'undo-tree-visualizer-select-left)
    (define-key undo-tree-visualizer-selection-mode-map (kbd "j") #'undo-tree-visualizer-select-next)
    (define-key undo-tree-visualizer-selection-mode-map (kbd "k") #'undo-tree-visualizer-select-previous)
    (define-key undo-tree-visualizer-selection-mode-map (kbd "l") #'undo-tree-visualizer-select-right)
    (define-key undo-tree-visualizer-selection-mode-map (kbd "<return>") #'undo-tree-visualizer-set)
    (add-hook 'undo-tree-visualizer-mode-hook (lambda () (setq undo-tree-visualizer-diff t)))) ; does this fix diff disappearing??
#+END_SRC
* shackle popup manager
** shackle configuration
#+BEGIN_SRC emacs-lisp
  (use-package shackle
    :hook (emacs-startup . shackle-mode)
    :init
    (setq shackle-default-size 0.4
          shackle-rules '((undo-tree-visualizer-mode :size 0.25 :align right :select t) ; doesn't seem to work somehow TODO
                          (help-mode :custom jay/shackle-dynamic-tyling :select t)
                          (occur-mode :align below :size 0.3 :select t)
                          (apropos-mode :custom jay/shackle-dynamic-tyling :select t)
                          (flycheck-error-list-mode :select t :align below :size 0.2)
                          (compilation-mode :noselect t :align below :size 0.2)
                          (special-mode :noselect t :align below :size 0.2)
                          (diff-mode :custom jay/shackle-dynamic-tyling :select t)
                          ("*Register Preview*" :noselect t :align above :size 0.2)
                          ("^\\*Org Src.*" :regexp t :popup nil))
          shackle-default-rule '(:popup t :select t)))
#+END_SRC
** custom window splitting
custom tiling function to create popups by splitting the current window
#+BEGIN_SRC emacs-lisp
  (with-eval-after-load 'shackle
    ;; get rid of compiler warnings
    (eval-when-compile
      (declare-function shackle--splittable-frame "shackle" ()))
    ;; stolen from https://emacs.stackexchange.com/a/37652
    (defun jay/shackle-dynamic-tyling (buffer alist plist)
      "Create a new window displaying BUFFER splitting the current window sensibly.
  If there already is a window displaying BUFFER, do nothing.
  ALIST is passed to `window--display-buffer'. PLIST is ignored."
      (or (get-buffer-window buffer)
          (let
              ((frame (shackle--splittable-frame))
               (window (if (> (* 1.4 (window-pixel-height)) (window-pixel-width))
                           (split-window-below)
                         (split-window-right (/ (window-width) -3)))))
            (prog1
                (window--display-buffer buffer window 'window alist display-buffer-mark-dedicated)
              (when window
                (shrink-window-if-larger-than-buffer window)
                (setq shackle-last-window window
                      shackle-last-buffer buffer))
              (unless (cdr (assq 'inhibit-switch-frame alist))
                (window--maybe-raise-frame frame)))))))
#+END_SRC
* rainbow-delimiters
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :diminish rainbow-delimiters-mode
    :hook (prog-mode . rainbow-delimiters-mode))
#+END_SRC
* rainbow-mode
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-mode
    :diminish rainbow-mode
    :hook prog-mode)
  ;; note: change rainbow-x-colors to nil to disable highlighting of color names
#+END_SRC
* expand-region
#+BEGIN_SRC emacs-lisp
  (use-package expand-region
    :bind (("C-=" . er/expand-region)))
#+END_SRC
* better regexp search/replace
#+BEGIN_SRC emacs-lisp
  (use-package visual-regexp-steroids
    :bind (("C-c r" . vr/replace)
           ("C-c q" . vr/query-replace)
           ("C-c M" . vr/mc-mark)))
#+END_SRC
* beacon
#+BEGIN_SRC emacs-lisp
  (use-package beacon
    :defer nil
    :diminish beacon-mode
    :init (setq beacon-push-mark 1)       ; this is a test (TODO)
    :config (beacon-mode 1))
#+END_SRC
* company (auto-completion)
#+BEGIN_SRC emacs-lisp
  (use-package company
    :defer nil
    :hook ;; (after-init . global-company-mode)
    ((prog-mode . company-mode)
     (text-mode . company-mode))
    :bind (:map company-mode-map
                ("C-\\" . company-complete))
    :diminish company-mode
    :init
    (setq company-idle-delay 0.1
          company-frontends
          '(company-semantic
            company-pseudo-tooltip-unless-just-one-frontend
            company-preview-frontend
            company-echo-metadata-frontend)
          company-auto-complete nil
          company-auto-complete-chars " !)+,-./:;<=>?@|}"
          company-require-match 'never
          company-transformers '(company-sort-by-occurrence company-sort-by-backend-importance)
          company-minimum-prefix-length 3
          ;; attempt at a whitelist for company global-modes
          ;; (currently not using company-global-mode)
          ;; company-global-modes
          ;; '(asm-mode autoconf-mode awk-mode bat-mode bibtex-mode
          ;; bibtex-style-mode change-log-mode c++-mode c-mode
          ;; comint-mode common-lisp-mode cperl-mode css-mode
          ;; emacs-lisp-mode fundamental-mode gdb-script-mode gfm-mode
          ;; ghci-script-mode git-commit-elisp-text-mode
          ;; git-commit-major-mode git-rebase-mode haskell-cabal-mode
          ;; haskell-mode html-mode indented-text-mode java-mode
          ;; javascript-mode js-mode latex-mode less-css-mode
          ;; lisp-interaction-mode lisp-mode log-edit-mode mail-mode
          ;; makefile-mode markdown-mode message-mode mhtml-mode
          ;; occur-edit-mode org-mode perl-mode plain-tex-mode
          ;; prog-mode python-mode rst-mode rust-mode scss-mode
          ;; sgml-mode shell-mode shell-script-mode sh-mode sql-mode
          ;; term-mode tex-mode text-mode vc-git-log-edit-mode
          ;; vhdl-mode xml-mode zone-mode)
          )
    :config
    (with-eval-after-load 'company
      ;; get rid of compiler warnings
      (eval-when-compile
        (declare-function yas-expand "yasnippet" (&optional field))
        (declare-function company-complete-common-or-cycle "company" (&optional arg))
        (declare-function company-indent-or-complete-common "company" ())
        (declare-function my/yas-expand-or-company-next "config" ())
        (declare-function my/yas-expand-or-company-indent-or-complete-common "config" ()))

      (defun my/yas-expand-or-company-next ()
        "Try to expand a yas snippet. If not possible, call `company-complete-common-or-cycle'"
        (interactive)
        (unless (yas-expand)
          (company-complete-common-or-cycle 1)))

      (defun my/yas-expand-or-company-indent-or-complete-common ()
        "Try to expand a yas snippet. If not possible, call `company-indent-or-complete-common'"
        (interactive)
        (if (equal major-mode 'org-mode)
            (call-interactively #'org-cycle)
          (unless (yas-expand)
            (company-indent-or-complete-common))))

      (define-key company-active-map (kbd "TAB") #'my/yas-expand-or-company-next)
      (define-key company-active-map (kbd "<tab>") #'my/yas-expand-or-company-next)
      (define-key company-active-map (kbd "S-TAB") (lambda () (interactive) (company-complete-common-or-cycle -1)))
      (define-key company-active-map (kbd "<backtab>") (lambda () (interactive) (company-complete-common-or-cycle -1)))
                                          ;    (define-key company-active-map (kbd "M-n") nil)
                                          ;    (define-key company-active-map (kbd "M-p") nil)
      (define-key company-active-map (kbd "C-c") 'counsel-company)
      (define-key company-active-map (kbd "C-n") (lambda () (interactive) (company-complete-common-or-cycle 1)))
      (define-key company-active-map (kbd "C-p") (lambda () (interactive) (company-complete-common-or-cycle -1)))
      (define-key company-mode-map (kbd "TAB") #'my/yas-expand-or-company-indent-or-complete-common)
      (define-key company-mode-map (kbd "<tab>") #'my/yas-expand-or-company-indent-or-complete-common)
      ))
#+END_SRC
** company quickhelp
#+BEGIN_SRC emacs-lisp
  (use-package company-quickhelp
    :hook (company-mode . company-quickhelp-local-mode)
    :init
    (setq company-quickhelp-use-propertized-text t
          ;; this seems to work a little better (at least in i3wm)
          pos-tip-use-relative-coordinates t))
#+END_SRC
* smartparens
#+BEGIN_SRC emacs-lisp
    (defun my/sp-kill-sexp-backward (prefix)
      "Revert the direction of the prefix argument and call `sp-kill-sexp' with it."
      (interactive "p")
      (sp-kill-sexp (- prefix)))

  (use-package smartparens
                                          ;:hook (prog-mode . turn-on-smartparens-strict-mode)
    :bind (:map smartparens-mode-map
                ("C-M-f"           . sp-forward-sexp)
                ("C-M-b"           . sp-backward-sexp)
                ("C-M-d"           . sp-down-sexp)
                ("C-M-u"           . sp-backward-up-sexp)
                ("C-M-a"           . sp-beginning-of-sexp)
                ("C-M-e"           . sp-end-of-sexp)
                ("C-M-n"           . sp-next-sexp)
                ("C-M-p"           . sp-previous-sexp)
                ("C-M-k"           . sp-kill-sexp)
                ("C-M-<backspace>" . my/sp-kill-sexp-backward)
                ("C-M-t"           . sp-transpose-sexp)
                ("M-s M-k"         . sp-kill-hybrid-sexp)
                ("C-K"             . sp-kill-hybrid-sexp)
                ("C-k"             . kill-line)
                ("M-s M-u"         . sp-backward-unwrap-sexp) ; TODO which of these bindings do I like best?
                ("M-s M-r"         . sp-rewrap-sexp)
                ("M-U"             . sp-backward-unwrap-sexp)
                ("M-R"             . sp-rewrap-sexp)
                ("M-]"             . sp-forward-slurp-sexp)
                ("M-s M-["         . sp-backward-slurp-sexp)
                ("M-["             . sp-forward-barf-sexp)
                ("M-s M-]"         . sp-backward-barf-sexp)
                ("M-s M-s"         . sp-slurp-hybrid-sexp)
                ("M-s M-t"         . sp-transpose-hybrid-sexp)
                ("M-s M-p"         . sp-push-hybrid-sexp)
                ("M-F"             . sp-forward-symbol)
                ("M-B"             . sp-backward-symbol)
                ("C-]"             . sp-change-inner)
                :map smartparens-strict-mode-map
                ("C-k"             . sp-kill-hybrid-sexp))
    :init
    (require 'smartparens-config)
    (require 'smartparens)
  ;; (show-smartparens-global-mode 1)
    (smartparens-global-mode 1))
#+END_SRC
* spaceline
#+BEGIN_SRC emacs-lisp
  (use-package spaceline
    :init
    (eval-when-compile
      (require 'powerline)
      (require 'spaceline-config)
      (require 'spaceline-segments))

    (setq powerline-default-separator 'bar
          spaceline-line-column-p nil
          spaceline-line-p nil
          spaceline-line-column-p t)
    (spaceline-spacemacs-theme))
#+END_SRC
* flycheck
#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :defer nil
    :bind (("M-g M-n" . flycheck-next-error)
           ("M-g M-p" . flycheck-previous-error)
           ("M-g M-f" . flycheck-first-error)
           ("M-g M-l" . flycheck-list-errors))
    :hook (after-init . global-flycheck-mode))
#+END_SRC
** flycheck-pos-tip
#+BEGIN_SRC emacs-lisp
  (use-package flycheck-pos-tip
    :after flycheck
    :config
    (with-eval-after-load 'flycheck
      (flycheck-pos-tip-mode)))
#+END_SRC
* dashboard
#+BEGIN_SRC emacs-lisp
  (use-package dashboard
    :defer nil
    :diminish page-break-lines-mode
    :init (setq dashboard-startup-banner 'logo
                dashboard-items '((recents   . 5)
                                  (bookmarks . 5)
                                  (projects  . 5)
                                  (agenda    . 5)
                                  (registers . 5))
                page-break-lines-char ?-)
    :config (dashboard-setup-startup-hook))
#+END_SRC
* TODO aggressive-indent
#+BEGIN_SRC emacs-lisp
  ;; (use-package aggressive-indent
  ;;   :hook (prog-mode . aggressive-indent-mode))
#+END_SRC
* hungry-delete (disabled)
#+BEGIN_SRC emacs-lisp
  (use-package hungry-delete
    :disabled
    :diminish hungry-delete-mode
    :hook (prog-mode . hungry-delete-mode))
#+END_SRC
* hl-todo
#+BEGIN_SRC emacs-lisp
  (defhydra hl-todo-navigation-hydra (:color pink)
    "navigate TODO items:"
    ("n" hl-todo-next "next")
    ("p" hl-todo-previous "prev")
    ("o" hl-todo-occur "occur" :exit t)
    ("q" nil)
    ("<escape>" nil)
    ("<return>" nil))

  (use-package hl-todo
    :commands (hl-todo-next hl-todo-previous hl-todo-occur)
    :hook (prog-mode . hl-todo-mode))

  (bind-key "M-s t" #'hl-todo-navigation-hydra/body prog-mode-map)
#+END_SRC
* highlight-indentation
#+BEGIN_SRC emacs-lisp
  (use-package highlight-indent-guides
    :disabled
    :init (setq highlight-indent-guides-method 'character)
    :hook (prog-mode . highlight-indent-guides-mode))
#+END_SRC
* TODO projectile
#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :defer nil
    :bind (("C-c p" . projectile-command-map))
    :init (setq projectile-completion-system 'ivy)
    :config (projectile-mode 1))   ; TODO
#+END_SRC
* TODO multiple-cursors
#+BEGIN_SRC emacs-lisp
  ;; stolen from https://github.com/abo-abo/hydra/wiki/multiple-cursors

  (defvar my/mark-even-if-inactive-backup nil "used by the hydra macro")

  (defhydra multiple-cursors-hydra (:hint nil
                                    ;; if I don't do this it breaks multiple cursors (as of 20180320.747)
                                    :pre (progn (setq my/mark-even-if-inactive-backup mark-even-if-inactive)
                                                (setq mark-even-if-inactive t))
                                    :post (setq mark-even-if-inactive my/mark-even-if-inactive-backup))
    "
       ^Up^            ^Down^        ^Other^
  ----------------------------------------------
  [_p_]   Next    [_n_]   Next    [_l_] Edit lines
  [_P_]   Skip    [_N_]   Skip    [_a_] Mark all
  [_M-p_] Unmark  [_M-n_] Unmark  [_r_] Mark by regexp
  ^ ^             ^ ^             [_d_] Mark all DWIM
  ^ ^             ^ ^             [_#_/_L_] Insert numbers/letters
  ^ ^             ^ ^             [_S_/_R_] Sort/Reverse regions
  ^ ^             ^ ^             [_q_] Quit
  "
    ;; calling it directly doesn't seem to work and even this is buggy
    ("l" (lambda () (interactive) (call-interactively 'mc/edit-lines)) :exit t)
    ("a" mc/mark-all-symbols-like-this :exit t)
    ("n" mc/mark-next-like-this-symbol)
    ("N" mc/skip-to-next-like-this)
    ("M-n" mc/unmark-next-like-this)
    ("p" mc/mark-previous-like-this-symbol)
    ("P" mc/skip-to-previous-like-this-symbol)
    ("M-p" mc/unmark-previous-like-this)
    ("r" mc/mark-all-in-region-regexp :exit t)
    ("d" mc/mark-all-like-this-dwim :exit t)
    ("#" mc/insert-numbers)
    ("L" mc/insert-letters)
    ("S" mc/sort-regions)
    ("R" mc/reverse-regions)
    ("q" nil))

  (use-package multiple-cursors
    :commands (mc/edit-lines
               mc/mark-all-symbols-like-this
               mc/mark-next-like-this-symbol
               mc/skip-to-next-like-this mc/unmark-next-like-this
               mc/mark-previous-like-this-symbol
               mc/skip-to-previous-like-this-symbol
               mc/unmark-previous-like-this
               mc/mark-all-in-region-regexp
               mc/mark-all-like-this-dwim mc/insert-numbers
               mc/insert-letters mc/sort-regions
               mc/reverse-regions)
    :bind (("C-c m" . multiple-cursors-hydra/body)
           ("C-c l" . mc/edit-lines) ; see above; the hydra binding doesn't really work
           :map mc/keymap ("<return>" . nil)))
#+END_SRC
* git-gutter
#+BEGIN_SRC emacs-lisp
  (use-package git-gutter
    :config (global-git-gutter-mode 1)

    ;; get rid of compiler warnings
    (eval-when-compile
      (declare-function git-gutter:next-hunk "git-gutter" (arg))
      (declare-function git-gutter:previous-hunk "git-gutter" (arg))
      (declare-function git-gutter:stage-hunk "git-gutter" ())
      (declare-function git-gutter:revert-hunk "git-gutter" ())
      (declare-function git-gutter:popup-hunk "git-gutter" (&optional diffinfo))
      (declare-function git-gutter:set-start-revision "git-gutter" (start-rev)))

    ;; stolen from: https://github.com/abo-abo/hydra/wiki/Git-gutter
    (global-set-key (kbd "C-c g")
                    (defhydra git-gutter-hydra (:hint nil)
                      "
  Git gutter:
    _j_: next hunk        _s_tage hunk     _q_uit
    _k_: previous hunk    _r_evert hunk    _Q_uit and deactivate git-gutter
    ^ ^                   _p_opup hunk
    _h_: first hunk
    _l_: last hunk        set start _R_evision
  "
                      ("j" git-gutter:next-hunk)
                      ("k" git-gutter:previous-hunk)
                      ("h" (progn (goto-char (point-min))
                                  (git-gutter:next-hunk 1)))
                      ("l" (progn (goto-char (point-min))
                                  (git-gutter:previous-hunk 1)))
                      ("s" git-gutter:stage-hunk)
                      ("r" git-gutter:revert-hunk)
                      ("p" git-gutter:popup-hunk)
                      ("R" git-gutter:set-start-revision)
                      ("C-l" reposition-window)
                      ("q" nil :color blue)
                      ("<escape>" nil)
                      ("<return>" nil)
                      ("Q" (progn (git-gutter-mode -1)
                                  ;; git-gutter-fringe doesn't seem to
                                  ;; clear the markup right away
                                  ;; TODO Do I actually need this?
                                  ;; (sit-for 0.1)
                                  ;; (git-gutter:clear)
                                  )
                       :color blue))))
#+END_SRC
* git-timemachine
#+BEGIN_SRC emacs-lisp
  (use-package git-timemachine
    :bind (("C-x t" . git-timemachine)))
#+END_SRC
* TODO origami
just an experiment for now; resolve key binding conflict!
#+BEGIN_SRC emacs-lisp
  (use-package origami
    :hook (emacs-startup . global-origami-mode)
    :defer nil
    :init
    ;; get rid of compiler warnings
    (eval-when-compile
      (declare-function origami-recursively-toggle-node "origami" (buffer point))
      (declare-function origami-open-node "origami" (buffer point))

      (declare-function origami-open-node-recursively "origami" (buffer point))
      (declare-function origami-close-node "origami" (buffer point))

      (declare-function origami-close-node-recursively "origami" (buffer point))
      (declare-function origami-forward-fold-same-level "origami" (buffer point))

      (declare-function origami-backward-fold-same-level "origami" (buffer point))
      (declare-function origami-next-fold "origami" (buffer point))

      (declare-function origami-previous-fold "origami" (buffer point))
      (declare-function origami-forward-toggle-node "origami" (buffer point))

      (declare-function origami-toggle-all-nodes "origami" (buffer point))
      (declare-function origami-show-only-node "origami" (buffer point))
      (declare-function origami-undo "origami" (buffer point))
      (declare-function origami-redo "origami" (buffer point)))

    (global-set-key
     (kbd "M-u")
     (defhydra hydra-folding (:color red :hint nil :idle 1)
       "
    _o_/_O_pen node    _j_ next fold       _t_oggle forward   _u_ndo
    _c_/_C_lose node   _k_ previous fold   toggle _a_ll       _r_edo

    _M-u_ toggle recursively           _f_ocus on current item
    "
       ("M-u" origami-recursively-toggle-node :color blue)
       ("o" origami-open-node)
       ("O" origami-open-node-recursively)
       ("c" origami-close-node)
       ("C" origami-close-node-recursively)
       ("j" origami-forward-fold-same-level)
       ("k" origami-backward-fold-same-level)
       ("J" origami-next-fold)
       ("K" origami-previous-fold)
       ("t" origami-forward-toggle-node)
       ("a" origami-toggle-all-nodes)
       ("f" origami-show-only-node :color blue)
       ("u" origami-undo)
       ("r" origami-redo))))
#+END_SRC
* magit
#+BEGIN_SRC emacs-lisp
  (use-package magit
    :bind (("C-x g" . magit-status)))
#+END_SRC
* org
#+BEGIN_SRC emacs-lisp
  (setq org-src-tab-acts-natively t
        org-src-fontify-natively t
        org-startup-indented t
        org-directory (expand-file-name "~/docs/orgs/")
        org-special-ctrl-a/e t
        org-special-ctrl-k t
        org-special-ctrl-o t
        org-src-window-setup 'current-window)
#+END_SRC
emacs lisp template
#+BEGIN_SRC emacs-lisp
  (add-to-list 'org-structure-template-alist
                 '("el" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC"))
#+END_SRC
** org-bullets
#+BEGIN_SRC emacs-lisp
  (use-package org-bullets
    :commands org-bullets-mode
    :hook (org-mode . org-bullets-mode))
#+END_SRC
** avoid arrow keys
#+BEGIN_SRC emacs-lisp
  (with-eval-after-load 'org
    (define-key org-mode-map (kbd "M-K") #'org-metaup)
    (define-key org-mode-map (kbd "M-J") #'org-metadown)
    (define-key org-mode-map (kbd "M-L") #'org-metaright)
    (define-key org-mode-map (kbd "M-H") #'org-metaleft)
    ;; use for sth. sensible later (I press those too often on accident)
    (define-key org-mode-map (kbd "M-n") (lambda () (interactive) (message "did it again...")))
    (define-key org-mode-map (kbd "M-p") (lambda () (interactive) (message "did it again...")))
    (define-key org-mode-map (kbd "M-N") (lambda () (interactive) (message "did it again...")))
    (define-key org-mode-map (kbd "M-P") (lambda () (interactive) (message "did it again..."))))
#+END_SRC
* html
#+BEGIN_SRC emacs-lisp
  ;; get rid of compiler warnings
  (eval-when-compile
    (declare-function sgml-electric-tag-pair-mode "sgml-mode" (arg)))

  (add-hook 'html-mode-hook #'sgml-electric-tag-pair-mode)
#+END_SRC
* TODO pdf
#+BEGIN_SRC emacs-lisp
  (use-package pdf-tools
    :init
    (setq pdf-info-epdfinfo-program "/usr/local/bin/epdfinfo")
    (setq pdf-view-midnight-colors `(,(face-attribute 'default :foreground) .
                                     ,(face-attribute 'default :background)))
    (add-to-list 'auto-mode-alist '("\\.pdf\\'" . pdf-view-mode))
    :config
    ;; get rid of compiler warnigns
    (eval-when-compile
      (declare-function pdf-view-midnight-minor-mode "pdf-view" (&optional arg)))

    (add-hook 'pdf-view-mode-hook (lambda () (pdf-view-midnight-minor-mode)
                                    (auto-revert-mode)))
    (pdf-tools-install))
#+END_SRC
* tex / latex
automatically enable spell checking in latex buffers
#+BEGIN_SRC emacs-lisp
  (eval-when-compile
    (require 'ispell))

  (add-hook 'tex-mode-hook
            #'(lambda () (setq ispell-parser 'tex) (flyspell-mode 1)))
#+END_SRC
* programming language specific configuration
** haskell
#+BEGIN_SRC emacs-lisp
  (use-package haskell-mode
    ;; :hook ((haskell-mode . haskell-doc-mode))
    ;; (haskell-mode . turn-on-haskell-unicode-input-method))
    :init
    ;; fix "unexpected response from haskell process" error
    ;; TODO remove if this gets fixed
    (eval-when-compile
      (require 'haskell))
    (setq haskell-process-args-ghci
          '("-ferror-spans" "-fshow-loaded-modules")
          haskell-process-args-cabal-repl
          '("--ghc-options=-ferror-spans -fshow-loaded-modules")
          haskell-process-args-stack-ghci
          '("--ghci-options=-ferror-spans -fshow-loaded-modules"
            "--no-build" "--no-load")
          haskell-process-args-cabal-new-repl
          '("--ghc-options=-ferror-spans -fshow-loaded-modules"))
    :config
    ;; stolen from https://haskell.github.io/haskell-mode/manual/latest/Completion-support.html#Completion-support
    (add-hook 'haskell-mode-hook
              (lambda ()
                (set (make-local-variable 'company-backends)
                     (append '((company-capf company-dabbrev-code)) company-backends)))))
#+END_SRC
*** hindent
#+BEGIN_SRC emacs-lisp
  (use-package hindent
    :after haskell-mode
    :hook (haskell-mode . hindent-mode))
#+END_SRC
*** interactive mode
#+BEGIN_SRC emacs-lisp
  (defun my/haskell-interactive-keybindings (&rest args)
      "Set up keybindings for haskell interactive mode. Ignore ARGS."
      (interactive)
      (define-key interactive-haskell-mode-map (kbd "M-.") #'haskell-mode-goto-loc)
      (define-key interactive-haskell-mode-map (kbd "C-c C-t") #'haskell-mode-show-type-at))

  ;; there doesn't seem to be a hook for interactive mode (?)
  (advice-add #'interactive-haskell-mode :after #'my/haskell-interactive-keybindings)
#+END_SRC
** rust
#+BEGIN_SRC emacs-lisp
  (use-package rust-mode)

  (use-package racer
    :diminish racer-mode
    :hook (rust-mode . racer-mode))

  (use-package cargo
    :diminish cargo-minor-mode
    :hook (rust-mode . cargo-minor-mode))
#+END_SRC
* yasnippet
#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :hook (after-init . yas-global-mode)
    :diminish (yas-minor-mode yas/minor-mode)
    :init
    (with-eval-after-load 'company
      ;; Add yasnippet support for all company backends
      ;; https://github.com/syl20bnr/spacemacs/pull/179
      (defvar company-mode/enable-yas t
        "Enable yasnippet for all backends.")

      ;; get rid of compiler warnings
      (eval-when-compile
        (declare-function company-mode/backend-with-yas "config" (backend))
        (declare-function my/add-yas-company-backends "config" ()))

      (defun company-mode/backend-with-yas (backend)
        (if (or (not company-mode/enable-yas) (and (listp backend) (member 'company-yasnippet backend)))
            backend
          (append (if (consp backend) backend (list backend))
                  '(:with company-yasnippet))))

      ;; (setq company-backends (mapcar #'company-mode/backend-with-yas company-backends))

      (defun my/add-yas-company-backends ()
        "Append (:with company-yasnippet) to every backend in company-backends that
  doesn't already contain it."
        (setq company-backends (mapcar #'company-mode/backend-with-yas company-backends)))
      (add-hook 'company-mode-hook #'my/add-yas-company-backends)))
#+END_SRC
* appearance
#+BEGIN_SRC emacs-lisp
    (setq ring-bell-function #'ignore
          inhibit-startup-screen t
          inhibit-x-resources t)

    ;; disable the startup message
    (defun display-startup-echo-area-message ())
#+END_SRC
** prettify symbols
#+BEGIN_SRC emacs-lisp
  (setq prettify-symbols-unprettify-at-point 'right-edge)
  (global-prettify-symbols-mode 1)
#+END_SRC
*** lisp
#+BEGIN_SRC emacs-lisp
  (add-hook 'emacs-lisp-mode-hook (lambda () (mapc (lambda (pair) (push pair prettify-symbols-alist))
                                              '(("nil" . "∅")))))
#+END_SRC
** appearance customisations only for graphical sessions
#+BEGIN_SRC emacs-lisp
  (when window-system
    (global-hl-line-mode 1)
    (tool-bar-mode 0)
    ;; (tooltip-mode 0)
    (scroll-bar-mode 0)
    (blink-cursor-mode 0)
    (setq use-dialog-box nil))
#+END_SRC
** mode line
#+BEGIN_SRC emacs-lisp
  (column-number-mode 1)
#+END_SRC
** input
insert some dead keys literally
#+BEGIN_SRC emacs-lisp
  (define-key key-translation-map [dead-grave] "`")
  (define-key key-translation-map [dead-acute] "'")
  (define-key key-translation-map [dead-circumflex] "^")
  (define-key key-translation-map [dead-diaeresis] "\"")
  (define-key key-translation-map [dead-tilde] "~")
#+END_SRC
** theme
#+BEGIN_SRC emacs-lisp
  (setq frame-background-mode 'dark)
#+END_SRC
#+BEGIN_SRC emacs-lisp
  (use-package gruvbox-theme
    :defer nil
    :init
    (load-theme 'gruvbox-dark-hard 'noconfirm))

  (use-package solarized-theme
    :defer nil
    :disabled
    :init (setq solarized-distinct-fringe-background t ; Make the fringe stand out from the background
                solarized-use-variable-pitch nil ; Don't change the font for some headings and titles
                solarized-high-contrast-mode-line nil ; Make the mode line high contrast
                solarized-use-less-bold t ; Use less bolding
                solarized-use-more-italic t ; Use more italics
                solarized-emphasize-indicators t
                solarized-scale-org-headlines t
                ;; Avoid all font-size changes
                solarized-height-minus-1 1.0
                solarized-height-plus-1 1.0
                solarized-height-plus-2 1.0
                solarized-height-plus-3 1.0
                solarized-height-plus-4 1.0
                x-underline-at-descent-line nil)
    :config (load-theme 'solarized-dark 'noconfirm))
#+END_SRC
** cursor
#+BEGIN_SRC emacs-lisp
  ;; make cursor match character width (e.g. for tab characters)
  (setq x-stretch-cursor t)
#+END_SRC
* ido
just a test
#+BEGIN_SRC emacs-lisp
  (use-package ido-vertical-mode
    :ensure nil
    :commands ido-vertical-mode)

  (use-package flx-ido
    :ensure nil
    :commands flx-ido-mode)

  (setq ido-use-virtual-buffers t)

  (defun my/enable-ido-test ()
    "just a test to see whether i like ido mode more than ivy for some use cases"
    (interactive)
    (ido-mode 1)
    (flx-ido-mode 1)
    (setq ido-enable-flex-matching t)
    (setq ido-everywhere t)
    (ido-vertical-mode 1)
    (global-set-key (kbd "M-x") 'smex))
#+END_SRC
* misc
** edit files as root using tramp
from the book "Mastering Emacs" (commented out since crux provides the same functionality)
#+BEGIN_SRC emacs-lisp
  ;; (defun my/sudo ()
  ;;   "Use TRAMP to `sudo' the current buffer"
  ;;   (interactive)
  ;;   (when buffer-file-name
  ;;     (find-alternate-file
  ;;      (concat "/sudo:root@localhost:"
  ;;              buffer-file-name))))
#+END_SRC
** kill word when region not active, else kill region
#+BEGIN_SRC emacs-lisp
  ;;   (defun my/backward-kill-word-or-kill-region (arg)
  ;;     "If the region is active, call `kill-region', else call `backward-kill-word'.
  ;; ARG is passed to `backward-kill-word' it it's called."
  ;;     (interactive "p")
  ;;     (if (region-active-p)
  ;;         (kill-region :ignore :ignore :use-region-instead)
  ;;       (backward-kill-word arg)))

  (defun my/backward-kill-word-or-kill-region ()
    "If the region is active, call `kill-region', else call `backward-kill-word'.
  ARG is passed to `backward-kill-word' it it's called."
    (interactive)
    (if (region-active-p)
        (call-interactively #'kill-region)
      (call-interactively #'backward-kill-word)))

  (global-set-key (kbd "C-w") 'my/backward-kill-word-or-kill-region)
#+END_SRC
** join line with next line (similar to J in vim)
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "M-J") (lambda () (interactive) (delete-indentation 1)))
#+END_SRC
** kill or yank whole line
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c k")
    (defhydra hydra-kill-line
      (:body-pre (kill-whole-line current-prefix-arg)
       :hint nil
       :idle 2)
  "
  _k_ill line
  "
      ("k" kill-whole-line)
      ("q" nil)
      ("<escape>" nil)
      ("<return>" nil)))

  ;; stolen from https://www.emacswiki.org/emacs/CopyingWholeLines
  (defun my/kill-ring-safe-whole-line (arg)
    "Copy ARG lines in the kill ring."
        (interactive "p")
        (kill-ring-save (line-beginning-position)
                        (line-beginning-position (+ 1 arg))))

  (defvar my/kill-hydra-prefix-arg 1
    "Used by `hydra-kill-ring-save-line'.")


  (global-set-key (kbd "C-c w")
    (defhydra hydra-kill-ring-save-line
      (:body-pre
       (progn (if (and current-prefix-arg (numberp current-prefix-arg))
                  (setq my/kill-hydra-prefix-arg current-prefix-arg)
                (setq my/kill-hydra-prefix-arg 1))
              (my/kill-ring-safe-whole-line my/kill-hydra-prefix-arg))
       :hint nil
       :idle 2)
  "
  _w_ yank line
  "
  ("w" (lambda ()
         (interactive)
         (setq my/kill-hydra-prefix-arg (+ 1 my/kill-hydra-prefix-arg))
         (my/kill-ring-safe-whole-line my/kill-hydra-prefix-arg)))
      ("q" nil)
      ("<escape>" nil)
      ("<return>" nil)))
#+END_SRC
** TODO evil
#+BEGIN_SRC emacs-lisp
  (defun my/toggle-evil ()
    "Toggle evil mode."
    (interactive)
    (call-interactively
     #'evil-mode)
    (unless (bound-and-true-p evil-mode)
      (setq-default cursor-type 'box)
      (setq cursor-type 'box)
      (set-cursor-color "#ffffff")))

  (use-package evil
    :bind*
    (("C-z" . my/toggle-evil))            ; doesn't always work; see below

    :init
    ;; indicate state via cursors
    (setq evil-normal-state-cursor '(box "firebrick")
          evil-emacs-state-cursor '(box "white")
          evil-insert-state-cursor '(bar "firebrick"))

    (defvar my/all-evil-states '(normal insert visual replace operator motion emacs)
      "contains a list of all evil states; useful for keybindings")

    :config
    ;; get rid of compiler warnigns
    (eval-when-compile
      (declare-function evil-normal-state "evil-states" (&optional arg))
      (declare-function evil-motion-state "evil-states" (&optional arg))
      (declare-function evil-insert-state "evil-states" (&optional arg))
      (declare-function evil-force-normal-state "evil-commands" (&optional arg))
      (declare-function evil-delay "evil-common" (condition form hook &optional append local name))
      (declare-function my/simulate-key-press "config" (key)))

    ;; make <escape> return to evil normal state from emacs mode
    (define-key evil-emacs-state-map (kbd "<escape>") #'evil-normal-state)

    ;; restore some emacs functionality in normal state
    (define-key evil-normal-state-map (kbd "C-n") #'next-line)
    (define-key evil-normal-state-map (kbd "C-p") #'previous-line)
    ;; (define-key evil-normal-state-map (kbd "C-e") #'end-of-line)
    (define-key evil-normal-state-map (kbd "<tab>") nil)

    ;; make insert state act more like emacs state (using emacs state
    ;; instead of insert state like this (defalias 'evil-insert-state
    ;; 'evil-emacs-state) doesn't work because it seems to break the dot
    ;; command)
    (setq evil-insert-state-map (make-sparse-keymap))
    (define-key evil-insert-state-map (kbd "<escape>") 'evil-normal-state)

    ;; this binding is here because the use-package binding seems to be
    ;; overwritten by evil
    (define-key evil-normal-state-map (kbd "C-z") #'my/toggle-evil)
    ;; those ones don't seem to work...
    (define-key evil-insert-state-map (kbd "C-z") #'my/toggle-evil)
    (define-key evil-emacs-state-map (kbd "C-z") #'my/toggle-evil)
    (define-key evil-operator-state-map (kbd "C-z") #'my/toggle-evil)


    ;; disable evil in some modes
    (dolist (mode '(flycheck-error-list-mode
                    term-mode))
      (add-to-list 'evil-emacs-state-modes mode))

    ;; fix tab key in help modes (not that this does NOT break C-i, at
    ;; least in GUI emacs)
    ;; (see below for better fix...)
    ;; (evil-define-key 'motion xhelp-mode-map       (kbd "<tab>") #'forward-button)
    ;; (evil-define-key 'motion racer-help-mode-map (kbd "<tab>") #'forward-button)
    ;; (evil-define-key 'motion intero-help-mode-map (kbd "<tab>") #'forward-button)
    ;; (evil-define-key 'motion apropos-mode-map (kbd "<tab>") #'forward-button)

    ;; (setq local-function-key-map (delq '(kp-tab . [9]) local-function-key-map))

    ;; in most cases where evil activates `evil-motion-state-map', using
    ;; `forward-button' for <tab> seems to be the right choice
    ;; when it's not you can still remap it for that partitular mode using
    ;; (evil-define-key 'motion your-mode-map (kbd "<tab>") #'my-function)
    ;; Amazingly, this does NOT break C-i (at least in GUI emacs)
    (define-key evil-motion-state-map (kbd "<tab>") #'forward-button)
    (evil-define-key my/all-evil-states org-mode-map (kbd "<tab>") #'org-cycle)

    ;; disable q in motion state (the default functionality seems more
    ;; useful than recording a _macro_...)
    (define-key evil-motion-state-map (kbd "q") nil)

    ;; fix racer help mode starting in normal state
    (add-hook 'racer-help-mode-hook #'evil-motion-state)

    (add-hook 'with-editor-mode-hook #'evil-insert-state)

    ;; make SPC in normal state act like C-c
    ;; stolen from https://emacs.stackexchange.com/a/13432
    (defun my/simulate-key-press (key)
      "Pretend that KEY was pressed.
  KEY must be given in `kbd' notation."
      `(lambda () (interactive)
         (setq prefix-arg current-prefix-arg)
         (setq unread-command-events (listify-key-sequence (read-kbd-macro ,key)))))

    (define-key evil-normal-state-map (kbd "SPC") (my/simulate-key-press "C-c"))

    ;; make SPC SPC act like M-x
    (define-key mode-specific-map (kbd "SPC") #'execute-extended-command)

    ;; just a crazy idea... (so that you can type SPC x instead of C-x)
    (global-set-key (kbd "C-c x") #'Control-X-prefix)

    ;; (define-key evil-normal-state-map (kbd "<escape>") #'ESC-prefix)
    (define-key evil-operator-state-map (kbd "<escape>") #'evil-force-normal-state))
#+END_SRC
** show startup message
#+BEGIN_SRC emacs-lisp
  (defun my/show-load-time ()
    (message (format "Loaded in %.2fs" (time-to-seconds (time-subtract after-init-time before-init-time)))))

  ;; somehow there's always another message shown if I run it with
  ;; emacs-startup-hook without a timer
  (add-hook 'emacs-startup-hook
            (lambda ()
              (run-with-idle-timer 1 nil #'my/show-load-time)))
#+END_SRC
